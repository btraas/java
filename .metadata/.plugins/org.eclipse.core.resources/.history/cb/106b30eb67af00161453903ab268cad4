package ca.bcit.comp2526.a2b;


import java.awt.Color;


/**
 * <p>A life.</p>
 * 
 * <p>Parent class of Animal, Plant etc.
 *  A life belongs to a Cell, and
 *  a cell contains 0 or 1 Life.</p>
 *  
 * <p>If no Cell contains this life,
 *  it's considered dead. Coincidentally,
 *  there will be no reference to this
 *  Life, and thus it will be GC'd from
 *  memory.</p>
 * 
 * @author Brayden Traas
 * @version 2016-10-22
 */
public enum LifeType implements Edible {

	/* Name, String, Color, inital food, Food Types, Incompatible move types */
	
	PLANT(		Color.GREEN, 			 // Base color
				10,						 // Turns before death
				new MoveStats(0, 0, 0),	 // Moves 0-0, senses 0
				new ReproductionStats(1, 2, (World.HEX ? 2 : 3), 2, 0),
				null, 					 // No food
				Terrain.getDifficults(), // Any "difficult" terrain
				null),					 // Don't avoid anything 
	
	HERBIVORE(	Color.YELLOW,	
				6,
				new MoveStats(1, 1, 2),
				new ReproductionStats(1, 2, 1, 2, 2),
				new Edible[] { 	SimpleLifeType.PLANT, Terrain.WATER }, 
				null, // No incompatible types
				new Matter[] { SimpleLifeType.CARNIVORE, SimpleLifeType.OMNIVORE }),
	
	CARNIVORE(	Color.RED, 
				3,
				new MoveStats(1, 2, 4),
				new ReproductionStats(1, 2, 1, 2, 2),
				new Edible[] { SimpleLifeType.HERBIVORE, SimpleLifeType.OMNIVORE },
				Terrain.getDifficults(),
				null
				),
	
	OMNIVORE(	Color.MAGENTA, 
				4,  
				new MoveStats(1, 1, 3),
				new ReproductionStats(1, 2, 1, 3, 3),
				new Edible[] { 	SimpleLifeType.PLANT, 
								SimpleLifeType.CARNIVORE, 
								Terrain.WATER },
				null,
				null);
	
	
	
	private Color color;
	private int initFood;

	private MoveStats move;
	private ReproductionStats reproduction;
	
	private Edible[] foodTypes;
	private Matter[] incompatibleTypes;
	private Matter[] avoid;
    
	private LifeType() {}
	
	private LifeType(	final Color color, 
						int initFood, 
						final MoveStats moveStats,
						final ReproductionStats reproductionStats,
						final Edible[] foodTypes, 
						final Matter[] incompatible,
						final Matter[] avoid) {
						
		
		this.color = color;
		this.initFood = initFood;
		this.move = moveStats;
		this.reproduction = reproductionStats;
		this.foodTypes = foodTypes;
		this.incompatibleTypes = incompatible;
		this.avoid = avoid;
	}
	
	private static final Matter[] simpleToComplex(Matter[] in) {
		for (int i = 0; i < in.length; i++) {
			if (in[i] instanceof SimpleLifeType) {
				SimpleLifeType simple = (SimpleLifeType)in[i];
				in[i] = simple.getLifeType();
			}
		}
		return in;
	}
	
	/**
	 * Gets the food types
	 * @return an array of Edible types.
	 */
	public Edible[] getFoodTypes() {
		return (Edible[])simpleToComplex(foodTypes);
	}

	/**
	 * Gets the Incompatible types
	 * @return an array of Matter types
	 */
	public Matter[] getIncompatibleTypes() {
		return simpleToComplex(incompatibleTypes);
	}

	/**
	 * Gets the Avoidable types.
	 * @return an array of Avoidable Matter
	 */
	public Matter[] getAvoid() {
		return simpleToComplex(avoid);
	}



	protected static enum SimpleLifeType implements Edible {
		PLANT, HERBIVORE, OMNIVORE, CARNIVORE;
		
		protected LifeType type;
		
		private SimpleLifeType() {
			type = getLifeType();
		}
		
		private LifeType getLifeType() {
			return LifeType.valueOf(this.name());
		}
		
	}
   
    protected static class ReproductionStats {
    	
    	protected int minSpawn;
    	protected int maxSpawn;
    	
    	protected int minNeighbors;
    	protected int minEmpty;
    	protected int minFood;
	    
    	private ReproductionStats(int minSpawn, int maxSpawn, 
    			int minNeighbors, int minEmpty, int minFood) {
    		this.minSpawn = minSpawn;
    		this.maxSpawn = maxSpawn;
    		this.minNeighbors = minNeighbors;
    		this.minEmpty = minEmpty;
    		this.minFood = minFood;
    	}
    }
    
    protected static class MoveStats {
    	
    	protected int min;
    	protected int max;
    	protected int sense;
    	
    	private MoveStats(int min, int max, int sense) {
    		if (max < min) {
    			try {
					throw new Exception("MAX > MIN!");
				} catch (Exception e) {
					e.printStackTrace();
				}
    		}
    		this.min = min;
    		this.max = max;
    		this.sense = sense;
    	}
    	
    }
    
}
