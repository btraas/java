package ca.bcit.comp2526.a2b;


import java.awt.Color;


/**
 * <p>A life.</p>
 * 
 * <p>Parent class of Animal, Plant etc.
 *  A life belongs to a Cell, and
 *  a cell contains 0 or 1 Life.</p>
 *  
 * <p>If no Cell contains this life,
 *  it's considered dead. Coincidentally,
 *  there will be no reference to this
 *  Life, and thus it will be GC'd from
 *  memory.</p>
 * 
 * @author Brayden Traas
 * @version 2016-10-22
 */
public enum LifeType implements Edible {

	// To add a LifeType, we need to add it here and in
	// LifeTools.Type, so they can refer to each other.
	
	/* Name, String, Color, inital food, Food Types, Incompatible move types */
	
	PLANT(		Color.GREEN, 			 // Base color
				10,						 // Turns before death
				new LifeTools.MoveStats(0, 0, 0),	 // Moves 0-0, senses 0
				new LifeTools.ReproductionStats(1, 2, (World.HEX ? 2 : 3), 2, 0),
				null, 					 // No food
				new LifeTools.IncompatibleArray(  // Any "difficult" terrain
						Terrain.getDifficults() ), 	
				null),					 // Don't avoid anything 
	
	HERBIVORE(	Color.YELLOW,	
				6,
				new LifeTools.MoveStats(1, 1, 2),
				new LifeTools.ReproductionStats(1, 2, 1, 2, 2),
				new Edible[] { 	LifeTools.Type.PLANT, Terrain.WATER }, 
				new LifeTools.IncompatibleArray( new Matter[] { 
						LifeTools.Type.HERBIVORE }),
				new LifeTools.AvoidArray( new Matter[] { 
						LifeTools.Type.CARNIVORE, 
						LifeTools.Type.OMNIVORE })),
	
	CARNIVORE(	Color.RED, 
				3,
				new LifeTools.MoveStats(1, 2, 4),
				new LifeTools.ReproductionStats(1, 2, 1, 2, 2),
				new Edible[] { 	LifeTools.Type.HERBIVORE, 
								LifeTools.Type.OMNIVORE },
				new LifeTools.IncompatibleArray(Matter.combine(
						Terrain.getDifficults(),
						new Matter[] { LifeTools.Type.CARNIVORE })),
				null
				),
	
	OMNIVORE(	Color.MAGENTA, 
				4,  
				new LifeTools.MoveStats(1, 1, 3),
				new LifeTools.ReproductionStats(1, 2, 1, 3, 3),
				new Edible[] { 	LifeTools.Type.PLANT, 
								LifeTools.Type.CARNIVORE, 
								Terrain.WATER },
				new Matter[] { LifeTools.Type.OMNIVORE },
				null);
	
	
	
	protected Color color;
	protected int initFood;

	protected LifeTools.MoveStats move;
	protected LifeTools.ReproductionStats reproduction;
	
	private Edible[] foodTypes;
	private LifeTools.IncompatibleArray incompatibleTypes;
	private LifeTools.AvoidArray avoid;
    
	private LifeType() {}
	
	private LifeType(	final Color color, 
						int initFood, 
						final LifeTools.MoveStats moveStats,
						final LifeTools.ReproductionStats reproductionStats,
						final Edible[] foodTypes, 
						final LifeTools.IncompatibleArray incompatible,
						final LifeTools.AvoidArray avoid) {
						
		
		this.color = color;
		this.initFood = initFood;
		this.move = moveStats;
		this.reproduction = reproductionStats;
		this.foodTypes = foodTypes;
		this.incompatibleTypes = incompatible;
		this.avoid = avoid;
	}
	
	private static final Matter[] simpleToComplex(Matter[] in) {
		if (in == null) {
			return null;// new Matter[]{};
		}
		for (int i = 0; i < in.length; i++) {
			if (in[i] instanceof LifeTools.Type) {
				LifeTools.Type simple = (LifeTools.Type)in[i];
				in[i] = LifeTools.getLifeType(simple);
			}
		}
		return in;
	}
	
	/**
	 * Gets the food types
	 * @return an array of Edible types.
	 */
	public Edible[] getFoodTypes() {
		//System.out.println(Arrays.asList(foodTypes));
		return (Edible[])simpleToComplex(foodTypes);
	}

	/**
	 * Gets the Incompatible types
	 * @return an array of Matter types
	 */
	public Matter[] getIncompatibleTypes() {
		return simpleToComplex(incompatibleTypes.data);
	}

	/**
	 * Gets the Avoidable types.
	 * @return an array of Avoidable Matter
	 */
	public Matter[] getAvoid() {
		return simpleToComplex(avoid.data);
	}


   
    
    
}
